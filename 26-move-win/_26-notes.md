## 1 提高窗口移动速度（1）（harib23a）
sheet.c sheet_refreshmap()
在进入bx和by的for循环之前先判断这个图层是否有透明部分，如果有透明部分的话还按现有程序执行，否则执行一个没有if语句的两层循环


## 2 提高窗口移动速度（2）（harib23b）
sheet.c sheet_refreshmap()
```
map[vy * ctl->xsize + vx] = sid;
```
这个命令的功能是向内存中某个地址写入sid的值，它也位于for循环中，会被反复执行，而且这个地址的后面以及再后面的地址也要写入sid的值。

在汇编语言中，如果用16位寄存器代替8位寄存器来执行MOV指令的话，相邻的地址中也会同时写入数据，而如果用32位寄存器，仅1条指令就可以同时向相邻的4个地址写入值了。

即便是同时写入4个字节的值，只要指定地址是4的整数倍，指令的执行速度就和1个字节的MOV是相同的。也就是说，速度说不定能提高到原来的4倍
```
  sid4 = sid | sid << 8 | sid << 16 | sid << 24;
```
为了让这次的修改发挥最大的效果，我们需要使窗口在x方向上的大小为4的倍数，而且窗口的x坐标也要为4的倍数。目前所有的窗口大小都是4的倍数，所以不需要修改了，而对于窗口坐标，我们需要做AND运算来取整，使打开窗口时的显示位置为4的倍数。
Change console.c *hrb_api()  edx = 5
```
  // ~3 = 0xfffffffc
	sheet_slide(sht, (shtctl->xsize - esi) / 2 & ~3, (shtctl->ysize - edi) / 2);
```

当用鼠标拖动窗口时如果目的地坐标不是4的倍数，我们这次的修改也就没有效果了，为了避免这种情况，我们必须保证目的地坐标为4的倍数才行。
bootpack.c HariMain()

## 3 提高窗口移动速度（3）（harib23c）
一次性写入4个字节可以有效地提高速度，也能用在sheet_refreshsub

当窗口显示位置为4的倍数时速度就会变快。重绘时重绘范围不一定为4的倍数，这种情况的处理方法：当前面有余数时将余数部分逐个字节处理，后面有余数时也一样。不过，即便窗口本身没有透明色，当它和别的窗口或者鼠标重叠时我们也不能直接往相邻的内存地址中写入数据，因此for循环中用来判断map的值是否等于sid的if语句还是不能去掉的。

## 4 提高窗口移动速度（4）（harib23d）
是因为移动窗口的时候，窗口移动的速度赶不上鼠标的速度，在放开鼠标键之后窗口还在那里挪动
因为伴随图层移动所进行的绘图操作非常消耗时间，导致系统来不及处理FIFO中的鼠标移动数据
我们可以等FIFO为空时再进行绘图操作

增加了new_mx和new_wy两个变量，并将原来的sheet_slide（sht_mouse, mx, my）；改成了new_mx = mx; new_my = my;，也就是并不真的移动鼠标图层的位置，而是将移动后的坐标暂且保存起来，当FIFO为空时，再执行sheet_slide（sht_mouse, new_mx, new_my）;。

## 5 启动时只打开一个命令行窗口（harib23e）
们就将启动时显示的命令行窗口数量改为一个，并且实现可以随意启动新命令行窗口的功能
规定按下Shift+F2就打开一个新的命令行窗口


## 6 增加更多的命令行窗口（harib23f）
sht_cons[]了，如果顺利的话，命令行窗口将不再有数量的限制，只要内存空间足够，就可以想开多少开多少。


## 7 关闭命令行窗口（1）（harib23g）
在Windows的命令行窗口中，输入“exit”命令就可以关闭当前窗口

关闭一个命令行窗口首先需要将创建该窗口时所占用的内存空间全部释放出来，然后还需要释放窗口的图层和任务结构

在创建任务时我们为命令行窗口准备了专用的栈，却没有将这个栈的地址保存起来，这样的话就无法执行释放操作了。
需要在TASK结构中添加一个cons_stack成员，用来保存栈的地址。

Update open_console
```
	task->cons_stack = memman_alloc_4k(memman, 64 * 1024);
```

Add command "exit" in cons_runcmd()


## 8 关闭命令行窗口（2）（harib23h）

