## 1 提高窗口移动速度（1）（harib23a）
sheet.c sheet_refreshmap()
在进入bx和by的for循环之前先判断这个图层是否有透明部分，如果有透明部分的话还按现有程序执行，否则执行一个没有if语句的两层循环


## 2 提高窗口移动速度（2）（harib23b）
sheet.c sheet_refreshmap()
```
map[vy * ctl->xsize + vx] = sid;
```
这个命令的功能是向内存中某个地址写入sid的值，它也位于for循环中，会被反复执行，而且这个地址的后面以及再后面的地址也要写入sid的值。

在汇编语言中，如果用16位寄存器代替8位寄存器来执行MOV指令的话，相邻的地址中也会同时写入数据，而如果用32位寄存器，仅1条指令就可以同时向相邻的4个地址写入值了。

即便是同时写入4个字节的值，只要指定地址是4的整数倍，指令的执行速度就和1个字节的MOV是相同的。也就是说，速度说不定能提高到原来的4倍
```
  sid4 = sid | sid << 8 | sid << 16 | sid << 24;
```
为了让这次的修改发挥最大的效果，我们需要使窗口在x方向上的大小为4的倍数，而且窗口的x坐标也要为4的倍数。目前所有的窗口大小都是4的倍数，所以不需要修改了，而对于窗口坐标，我们需要做AND运算来取整，使打开窗口时的显示位置为4的倍数。
Change console.c *hrb_api()  edx = 5
```
  // ~3 = 0xfffffffc
	sheet_slide(sht, (shtctl->xsize - esi) / 2 & ~3, (shtctl->ysize - edi) / 2);
```

当用鼠标拖动窗口时如果目的地坐标不是4的倍数，我们这次的修改也就没有效果了，为了避免这种情况，我们必须保证目的地坐标为4的倍数才行。
bootpack.c HariMain()

## 3 提高窗口移动速度（3）（harib23c）
一次性写入4个字节可以有效地提高速度，也能用在sheet_refreshsub

当窗口显示位置为4的倍数时速度就会变快。重绘时重绘范围不一定为4的倍数，这种情况的处理方法：当前面有余数时将余数部分逐个字节处理，后面有余数时也一样。不过，即便窗口本身没有透明色，当它和别的窗口或者鼠标重叠时我们也不能直接往相邻的内存地址中写入数据，因此for循环中用来判断map的值是否等于sid的if语句还是不能去掉的。