
## 为什么要分段

	汇编语言有一个ORG指令，如果不用ORG指令明确声明程序要读入的内存地址，就不能写出正确的程序来。

	当操作系统同时运行多个程序时，需要避免多个程序被加载到相同的地址空间。

	分段就是将4GB的内存分成很多block，每一块的起始地址都看作0。有了这个功能，任何程序都可以先写上一句ORG 0。
	像这样分割出来的块，就称为段（segment）

## 寻址
16位段式寻址

8086 CPU中设置了四个段寄存器：CS、DS、SS和ES，分别用于可执行代码段、数据段、堆栈段及其他段
```
  MOV AL, [DS:EBX] 
```
address = DS * 16 + EBX


32位段式寻址
```
  MOV AL, [DS:EBX] 
```
address = DS所表示的段的起始地址 + EBX


即使省略段寄存器（segment register）的地址，也会自动认为是指定了DS。这个规则不管是16位模式还是32位模式，都是一样的。


32位下段的信息有
- 段的大小是多少 
- 段的起始地址在哪里
- 段的管理属性（禁止写入，禁止执行，系统专用等）

用8bytes(64bits)表示

32位下段寄存器还是16位, 存储的不是段地址, 而是 segment selector, 

然后找一块内存来存储段信息, 段寄存器是16位，所以本来应该能够处理0～65535范围的数，但由于CPU设计上的原因，段寄存器的低3位不能使用。因此能够使用的段号只有13位，即段号可以是0～8191的数, 即可以定义8192个段，所以设定这么多段就需要8192×8=65536字节（64KB）
这段存放段信息的内存被称为 GDT(global（segment）descriptor table)

这段内存的起始地址和大小被放在 GDTR 寄存器中.

GDTR 有48位，不能用MOV指令来赋值。 给它赋值的时候，唯一的方法就是指定一个内存地址，用LGDT指令从指定的地址读取6个字节（也就是48位）

GDTR的低16位（即内存的最初2个字节）是段上限，它等于“GDT的有效字节数 -1”。 
高32位（即剩余的4个字节），代表GDT的开始地址。

```
; 指定的段上限（limit）和地址值赋值给GDTR寄存器。
; GDTR 有 48位寄存器，不能用MOV指令来赋值。
; 需要使用 LGDT 指令从指定的地址读取6个字节（也就是48位），
; GDTR 低16位（即内存的最初2个字节）是段上限，它等于“GDT的有效字节数 -1”。
;      高32位（即剩余的4个字节），代表GDT的开始地址。
_load_gdtr:		; void load_gdtr(int limit, int addr);
   MOV		AX,[ESP+4]		; 此时 limit在[ESP+4], addr在[ESP+8]
   MOV		[ESP+6],AX    ; 把limit写入 [ESP+6]
   LGDT	  [ESP+6]       ; 从[ESP+6] 正好可以连续读取 limit, addr 
   RET

_load_idtr:		; void load_idtr(int limit, int addr);
   MOV		AX,[ESP+4]		; limit
   MOV		[ESP+6],AX
   LIDT	[ESP+6]
   RET
```

12位段属性 ar 的高4位是扩展访问权限, 由 GD00构成
G(granularity) =1 limit的单位为4KB, =0时limit的单位为1byte
D =1 是32位模式, =0是 16位模式

高4位放在limit_high的高4位里，所以程序里有意把ar当作如下的16位构成来处理：xxxx0000xxxxxxxx


ar的低8位
```
  00000000 (0x00) 未使用
  10010010 (0x92) 系统专用, 可读写, 不可执行
  10011010 (0x9a) 系统专用, 可读不可写, 可执行
  11110010 (0xf2) 程序用, 可读写, 不可执行
  11111010 (0xfa) 程序用, 可读不可写, 可执行
```
CPU到底是处于系统模式还是应用模式，取决于执行中的应用程序是位于访问权为0x9a的段，还是位于访问权为0xfa的段。

