## 1 编写malloc（harib20a）

如果api_malloc只是调用操作系统中的memman_alloc，并将分配到的内存空间地址返回给应用程序的话，是行不通的，因为通过memman_alloc所获得的内存空间并不位于应用程序的数据段范围内，应用程序是无法进行读写操作的

应用程序可以进行读写的只是最开始操作系统为它准备好的数据段中的内存空间而已，那么如果我们一开始就将应用程序用的数据段分配得大一点，当需要malloc的时候从多余的空间里面拿出一小部分来交给应用程序不就好了吗

```
$(BIM2HRB) winhelo2.bim winhelo2.hrb 0
```
当指定了malloc所需内存大小时，这个数值会和栈等的大小进行累加，并写入．hrb文件最开头的4个字节中。因此，操作系统不需要做任何改动，就可以确保在应用程序段中分配到包括malloc所需部分在内的全部内存空间。
同时，malloc用的内存空间在数据段中的开始位置，被保存在．hrb文件的0x0020处。


## 2 画点（harib20b）
edx == 11



## 3 刷新窗口（harib20c）
这个选项要如何指定呢？窗口句柄归根到底是struct SHEET的地址，这一定是一个偶数，那么我们可以让程序在指定一个奇数（即在原来的数值上加1）的情况下不进行自动刷新。

edx == 12



## 4 画直线（harib20d）
先要做的是计算len，通过比较直线起点和终点的坐标，将变化比较大的作为len（实际上还需要加上1）。
为什么要加上1呢？因为如果不这样做的话，画到最后就会差1个像素。举个例子，当起点和终点完全相同时，应该在画面上画出1个点才对，但此时dx和dy都为0，如果不加1就什么都画不出来了。

len计算出来以后，接着计算dx和dy。将变化比较大的一方设为1024或者-1024（即1或-1），变化较小的一方用变化量去除以len。在做除法的时候我们还是会进行加1和减1的运算，

## 5 关闭窗口（harib20e）
edx == 14


## 6 键盘输入API（harib20f）
当按下回车键时再结束运行，这样就不会出现窗口显示时间过短的问题了。要接受键盘输入，其实只要从和任务绑定的FIFO缓冲区中取出1个就可以了



## 7 用键盘输入来消遣一下（harib20g）



## 8 强制结束并关闭窗口（harib20h）
我们在struct SHEET中添加一个用来存放task的成员，当应用程序结束时，查询所有的图层，如果图层的task为将要结束的应用程序任务，则关闭该图层。



