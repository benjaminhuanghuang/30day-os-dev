## 1 蜂鸣器发声（harib22a）

音高操作 
AL = 0xb6; OUT(0x43, AL)； 
AL = 设定值的低位8bit; OUT(0x42, AL)；
AL = 设定值的高位8bit; OUT(0x42, AL)； 
设定值为0时当作65536来处理。 
发声的音高为时钟除以设定值，也就是说设定值为1000时相当于发出1.19318KHz的声音；设定值为10000时相当于119.318Hz。因此设定2712即可发出约440Hz的声音


蜂鸣器ON/OFF 
使用I/O端口0x61控制。 
ON:IN(AL, 0x61); AL |= 0x03; AL &= 0x0f; OUT(0x61, AL)； 
OFF:IN(AL, 0x61); AL &= 0xd; OUT(0x61, AL)；


## 2 增加更多的颜色（1）（harib22b）


## 4 窗口初始位置（harib22d）
希望让窗口总是显示在画面的中央，而且显示窗口时的图层高度也不能总是固定为3，而是要判断当前画面中窗口的数量并自动显示在最上面

edx = 5

## 5 增加命令行窗口（1）（harib22e）
目前不能同时启动两个应用程序

要解决这个问题，可以考虑修改一下命令行窗口，使其在应用程序运行中就可以输入下一条命令，不过这样的修改量实在太大，讲解起来也会很麻烦，
因此改用同时启动两个命令行窗口

task_cons -> task_cons[0]和task_cons[1]

## 6 增加命令行窗口（2）（harib22f）
每个task 必须有各自独立的 consol 和 ds_base
```
struct TASK {
    int sel, flags; /＊ sel代表GDT编号＊/
    int level, priority;
    struct FIFO32 fifo;
    struct TSS32 tss;
    struct CONSOLE *cons;   
    int ds_base;             
};
```


## 7 增加命令行窗口（3）（harib22g）
上面这段代码是用来创建应用程序段并启动应用程序的，大家仔细思考一下这段代码。首先，color.hrb在某个窗口中被运行，启动程序一切顺利，然后显示窗口并绘图，接下来等待键盘输入并进入休眠状态。到这里为止没有任何问题。然后我们在另外一个窗口中运行color.hrb，程序也顺利启动了，显示窗口并绘图，随后进入休眠状态。然而在这个时候，问题其实已经发生了。这是怎么回事呢？因为我们为color.hrb准备的1003号代码段和1004号数据段，被color2.hrb所用的段给覆盖掉了。因此，当按下回车键唤醒color.hrb时，就会发生异常情况——明明应该去运行color.hrb的，结果却错误地运行了color2.hrb，这样当然会出错了。


只要为color.hrb和color2.hrb分配编号不同的段. Change cmd_app()

在task->sel中填入TSS的段号 * 8（请参照mtask.c的task_init），将这个值除以8，结果一定落在3～1002。将其加上1000，就得到1003～2002的值，我们把它用作应用程序用的代码段编号；将其加上2000，即得到2003～3002的值，我们把它用作应用程序用的数据段编号。这样一来，就不会发生段被覆盖的问题了。


## 8 增加命令行窗口（4）（harib22h）
Fix 道Shift+F1和“×”按钮


## 9 变得更像真正的操作系统（1）（harib22i）

remove task_a from bootpack.c


## 10 变得更像真正的操作系统（2）（harib22j）

